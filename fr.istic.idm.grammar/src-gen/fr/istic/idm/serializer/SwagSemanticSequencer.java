/*
 * generated by Xtext 2.25.0
 */
package fr.istic.idm.serializer;

import com.google.inject.Inject;
import fr.istic.idm.services.SwagGrammarAccess;
import fr.istic.idm.swag.AllFilter;
import fr.istic.idm.swag.ArrayNode;
import fr.istic.idm.swag.BasicNode;
import fr.istic.idm.swag.BoundFilter;
import fr.istic.idm.swag.EqualFilter;
import fr.istic.idm.swag.ExistFilter;
import fr.istic.idm.swag.JsonBoolean;
import fr.istic.idm.swag.JsonNull;
import fr.istic.idm.swag.JsonNumber;
import fr.istic.idm.swag.JsonString;
import fr.istic.idm.swag.ListFilter;
import fr.istic.idm.swag.NullableInt;
import fr.istic.idm.swag.Path;
import fr.istic.idm.swag.SwagPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SwagSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SwagGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SwagPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SwagPackage.ALL_FILTER:
				sequence_AllFilter(context, (AllFilter) semanticObject); 
				return; 
			case SwagPackage.ARRAY_NODE:
				sequence_ArrayNode(context, (ArrayNode) semanticObject); 
				return; 
			case SwagPackage.BASIC_NODE:
				sequence_BasicNode(context, (BasicNode) semanticObject); 
				return; 
			case SwagPackage.BOUND_FILTER:
				if (rule == grammarAccess.getFilterRule()
						|| rule == grammarAccess.getBoundFilterRule()) {
					sequence_BoundFilter(context, (BoundFilter) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getBoundFilterAccess().getBoundFilterMaxAction_2_1()) {
					sequence_BoundFilter_BoundFilter_2_1(context, (BoundFilter) semanticObject); 
					return; 
				}
				else break;
			case SwagPackage.EQUAL_FILTER:
				sequence_EqualFilter(context, (EqualFilter) semanticObject); 
				return; 
			case SwagPackage.EXIST_FILTER:
				sequence_ExistFilter(context, (ExistFilter) semanticObject); 
				return; 
			case SwagPackage.JSON_BOOLEAN:
				sequence_JsonBoolean(context, (JsonBoolean) semanticObject); 
				return; 
			case SwagPackage.JSON_NULL:
				sequence_JsonNull(context, (JsonNull) semanticObject); 
				return; 
			case SwagPackage.JSON_NUMBER:
				sequence_JsonNumber(context, (JsonNumber) semanticObject); 
				return; 
			case SwagPackage.JSON_STRING:
				sequence_JsonString(context, (JsonString) semanticObject); 
				return; 
			case SwagPackage.LIST_FILTER:
				sequence_ListFilter(context, (ListFilter) semanticObject); 
				return; 
			case SwagPackage.NULLABLE_INT:
				sequence_NullableInt(context, (NullableInt) semanticObject); 
				return; 
			case SwagPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Filter returns AllFilter
	 *     AllFilter returns AllFilter
	 *
	 * Constraint:
	 *     {AllFilter}
	 */
	protected void sequence_AllFilter(ISerializationContext context, AllFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns ArrayNode
	 *     ArrayNode returns ArrayNode
	 *
	 * Constraint:
	 *     ((str=ID | str=STRING) filter=ListFilter?)
	 */
	protected void sequence_ArrayNode(ISerializationContext context, ArrayNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns BasicNode
	 *     BasicNode returns BasicNode
	 *
	 * Constraint:
	 *     (str=ID | str=STRING)
	 */
	protected void sequence_BasicNode(ISerializationContext context, BasicNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns BoundFilter
	 *     BoundFilter returns BoundFilter
	 *
	 * Constraint:
	 *     ((min=NullableInt max=NullableInt?) | max=NullableInt | max=BoundFilter_BoundFilter_2_1)
	 */
	protected void sequence_BoundFilter(ISerializationContext context, BoundFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundFilter.BoundFilter_2_1 returns BoundFilter
	 *
	 * Constraint:
	 *     min=NullableInt
	 */
	protected void sequence_BoundFilter_BoundFilter_2_1(ISerializationContext context, BoundFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.BOUND_FILTER__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.BOUND_FILTER__MIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundFilterAccess().getMinNullableIntParserRuleCall_2_0_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns EqualFilter
	 *     PathFilter returns EqualFilter
	 *     EqualFilter returns EqualFilter
	 *
	 * Constraint:
	 *     (path=Path value=JsonValue)
	 */
	protected void sequence_EqualFilter(ISerializationContext context, EqualFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH));
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.EQUAL_FILTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.EQUAL_FILTER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualFilterAccess().getPathPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getEqualFilterAccess().getValueJsonValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ExistFilter
	 *     PathFilter returns ExistFilter
	 *     ExistFilter returns ExistFilter
	 *
	 * Constraint:
	 *     path=Path
	 */
	protected void sequence_ExistFilter(ISerializationContext context, ExistFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistFilterAccess().getPathPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonBoolean
	 *     JsonBoolean returns JsonBoolean
	 *
	 * Constraint:
	 *     (bool='true' | bool='false')
	 */
	protected void sequence_JsonBoolean(ISerializationContext context, JsonBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonNull
	 *     JsonNull returns JsonNull
	 *
	 * Constraint:
	 *     {JsonNull}
	 */
	protected void sequence_JsonNull(ISerializationContext context, JsonNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonNumber
	 *     JsonNumber returns JsonNumber
	 *
	 * Constraint:
	 *     number=INT
	 */
	protected void sequence_JsonNumber(ISerializationContext context, JsonNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.JSON_NUMBER__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.JSON_NUMBER__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonNumberAccess().getNumberINTTerminalRuleCall_1_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonString
	 *     JsonString returns JsonString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_JsonString(ISerializationContext context, JsonString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.JSON_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.JSON_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonStringAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListFilter returns ListFilter
	 *
	 * Constraint:
	 *     (filter+=Filter filter+=Filter*)
	 */
	protected void sequence_ListFilter(ISerializationContext context, ListFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NullableInt returns NullableInt
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NullableInt(ISerializationContext context, NullableInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.NULLABLE_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.NULLABLE_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullableIntAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (node+=Node nodes+=Node*)?
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
