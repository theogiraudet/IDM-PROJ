/*
 * generated by Xtext 2.25.0
 */
package fr.istic.idm.serializer;

import com.google.inject.Inject;
import fr.istic.idm.services.SwagGrammarAccess;
import fr.istic.idm.swag.AllFilter;
import fr.istic.idm.swag.ArrayNode;
import fr.istic.idm.swag.BasicNode;
import fr.istic.idm.swag.BoundFilter;
import fr.istic.idm.swag.ComplexPath;
import fr.istic.idm.swag.EqualFilter;
import fr.istic.idm.swag.ExistFilter;
import fr.istic.idm.swag.IndexFilter;
import fr.istic.idm.swag.JsonBoolean;
import fr.istic.idm.swag.JsonNull;
import fr.istic.idm.swag.JsonNumber;
import fr.istic.idm.swag.JsonString;
import fr.istic.idm.swag.ListFilter;
import fr.istic.idm.swag.RootPath;
import fr.istic.idm.swag.SwagPackage;
import fr.istic.idm.swag.WrappedInt;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SwagSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SwagGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SwagPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SwagPackage.ALL_FILTER:
				sequence_AllFilter(context, (AllFilter) semanticObject); 
				return; 
			case SwagPackage.ARRAY_NODE:
				sequence_ArrayNode(context, (ArrayNode) semanticObject); 
				return; 
			case SwagPackage.BASIC_NODE:
				sequence_BasicNode(context, (BasicNode) semanticObject); 
				return; 
			case SwagPackage.BOUND_FILTER:
				sequence_BoundFilter(context, (BoundFilter) semanticObject); 
				return; 
			case SwagPackage.COMPLEX_PATH:
				sequence_ComplexPath(context, (ComplexPath) semanticObject); 
				return; 
			case SwagPackage.EQUAL_FILTER:
				sequence_EqualFilter(context, (EqualFilter) semanticObject); 
				return; 
			case SwagPackage.EXIST_FILTER:
				sequence_ExistFilter(context, (ExistFilter) semanticObject); 
				return; 
			case SwagPackage.INDEX_FILTER:
				sequence_IndexFilter(context, (IndexFilter) semanticObject); 
				return; 
			case SwagPackage.JSON_BOOLEAN:
				sequence_JsonBoolean(context, (JsonBoolean) semanticObject); 
				return; 
			case SwagPackage.JSON_NULL:
				sequence_JsonNull(context, (JsonNull) semanticObject); 
				return; 
			case SwagPackage.JSON_NUMBER:
				sequence_JsonNumber(context, (JsonNumber) semanticObject); 
				return; 
			case SwagPackage.JSON_STRING:
				sequence_JsonString(context, (JsonString) semanticObject); 
				return; 
			case SwagPackage.LIST_FILTER:
				sequence_ListFilter(context, (ListFilter) semanticObject); 
				return; 
			case SwagPackage.ROOT_PATH:
				sequence_RootPath(context, (RootPath) semanticObject); 
				return; 
			case SwagPackage.WRAPPED_INT:
				sequence_WrappedInt(context, (WrappedInt) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Filter returns AllFilter
	 *     AllFilter returns AllFilter
	 *
	 * Constraint:
	 *     {AllFilter}
	 */
	protected void sequence_AllFilter(ISerializationContext context, AllFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns ArrayNode
	 *     ArrayNode returns ArrayNode
	 *
	 * Constraint:
	 *     ((str=ID | str=STRING) filter=ListFilter?)
	 */
	protected void sequence_ArrayNode(ISerializationContext context, ArrayNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns BasicNode
	 *     BasicNode returns BasicNode
	 *
	 * Constraint:
	 *     (str=ID | str=STRING)
	 */
	protected void sequence_BasicNode(ISerializationContext context, BasicNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns BoundFilter
	 *     BoundFilter returns BoundFilter
	 *
	 * Constraint:
	 *     ((min=WrappedInt max=WrappedInt?) | max=WrappedInt)
	 */
	protected void sequence_BoundFilter(ISerializationContext context, BoundFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path returns ComplexPath
	 *     ComplexPath returns ComplexPath
	 *
	 * Constraint:
	 *     (nodes+=Node nodes+=Node*)?
	 */
	protected void sequence_ComplexPath(ISerializationContext context, ComplexPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns EqualFilter
	 *     PathFilter returns EqualFilter
	 *     EqualFilter returns EqualFilter
	 *
	 * Constraint:
	 *     (path=Path value=JsonValue)
	 */
	protected void sequence_EqualFilter(ISerializationContext context, EqualFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH));
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.EQUAL_FILTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.EQUAL_FILTER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualFilterAccess().getPathPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getEqualFilterAccess().getValueJsonValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ExistFilter
	 *     PathFilter returns ExistFilter
	 *     ExistFilter returns ExistFilter
	 *
	 * Constraint:
	 *     path=Path
	 */
	protected void sequence_ExistFilter(ISerializationContext context, ExistFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.PATH_FILTER__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistFilterAccess().getPathPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IndexFilter
	 *     IndexFilter returns IndexFilter
	 *
	 * Constraint:
	 *     index=NATURAL_INT
	 */
	protected void sequence_IndexFilter(ISerializationContext context, IndexFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.INDEX_FILTER__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.INDEX_FILTER__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexFilterAccess().getIndexNATURAL_INTTerminalRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonBoolean
	 *     JsonBoolean returns JsonBoolean
	 *
	 * Constraint:
	 *     (bool='true' | bool='false')
	 */
	protected void sequence_JsonBoolean(ISerializationContext context, JsonBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonNull
	 *     JsonNull returns JsonNull
	 *
	 * Constraint:
	 *     {JsonNull}
	 */
	protected void sequence_JsonNull(ISerializationContext context, JsonNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonNumber
	 *     JsonNumber returns JsonNumber
	 *
	 * Constraint:
	 *     number=NATURAL_INT
	 */
	protected void sequence_JsonNumber(ISerializationContext context, JsonNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.JSON_NUMBER__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.JSON_NUMBER__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonNumberAccess().getNumberNATURAL_INTTerminalRuleCall_1_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonValue returns JsonString
	 *     JsonString returns JsonString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_JsonString(ISerializationContext context, JsonString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.JSON_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.JSON_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonStringAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListFilter returns ListFilter
	 *
	 * Constraint:
	 *     (filter+=Filter filter+=Filter*)
	 */
	protected void sequence_ListFilter(ISerializationContext context, ListFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path returns RootPath
	 *     RootPath returns RootPath
	 *
	 * Constraint:
	 *     {RootPath}
	 */
	protected void sequence_RootPath(ISerializationContext context, RootPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WrappedInt returns WrappedInt
	 *
	 * Constraint:
	 *     number=NATURAL_INT
	 */
	protected void sequence_WrappedInt(ISerializationContext context, WrappedInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SwagPackage.Literals.WRAPPED_INT__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SwagPackage.Literals.WRAPPED_INT__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWrappedIntAccess().getNumberNATURAL_INTTerminalRuleCall_1_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
}
